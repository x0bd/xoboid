const id = "terminal-art/index.md";
						const collection = "blog";
						const slug = "terminal-art";
						const body = "\r\nI've been playing around with [p5.js](https://p5js.org/) for creating generative sketches, and the urge to experiment with ASCII art struck. I built a browser based ascii art generator with p5.js, but the performance was abysmal. This led me down the path of building one with Rust, and let me tell you, it was a revelation. The Rust version was **blazingly** fast, super lightweight, and surprisingly straightforward to create.\r\n\r\nNow, let's dive in and see how you can build your own terminal ASCII art generator in Rust!\r\n\r\n## Setting Up the Project\r\n\r\n1. **Create a new Rust project:**\r\n\r\n    Open your terminal and run `cargo init <project_name>`. Replace `<project_name>` with your desired name (e.g., `rascii`). This command creates the basic structure for your Rust project.\r\n\r\n2. **Add Dependencies:**\r\n\r\n    We'll be using the `image` crate to handle image manipulation. Add the following line to your `Cargo.toml` file located in the project root directory:\r\n\r\n    ```toml\r\n    [dependencies]\r\n    image = \"0.25.0\"\r\n    ```\r\n\r\n3. **Install Dependencies:**\r\n\r\n    Run `cargo build` in your terminal to download and install the `image` crate for your project.\r\n\r\n## Understanding the Code\r\n\r\nNow, let's break down the core functionality of the code step-by-step:\r\n\r\n**1. Importing the `image` crate:**\r\n\r\n```rust\r\nuse image::{ GenericImageView };\r\n```\r\n\r\nThis line brings the functionality of the `image` crate into scope for our program. We use the `GenericImageView` trait, which allows us to work with different image formats.\r\n\r\n**2. `get_ascii` Function:**\r\n\r\n```rust\r\nfn get_ascii(intent: u8) -> &'static str {\r\n    let index = intent / 32;\r\n    let ascii = [\" \", \".\", \",\", \"-\", \"~\", \"+\", \"=\", \"@\"];\r\n    return ascii[index as usize];\r\n}\r\n```\r\n\r\nThis function takes an `intent` value (represented as an unsigned 8-bit integer) and converts it into an ASCII character representing the brightness level.\r\n\r\n-   `intent` is calculated by averaging the red, green, and blue (RGB) values of a pixel.\r\n-   The function uses a pre-defined array `ascii` containing various characters representing different brightness levels. (\" \" for darkest, \"@\" for brightest).\r\n-   It divides `intent` by 32 to get an index into the `ascii` array.\r\n-   Finally, it returns the corresponding ASCII character at that index.\r\n\r\n**3. `get_image` Function:**\r\n\r\n```rust\r\nfn get_image(dir: &str, scale: u32) {\r\n    let img = image::open(dir).unwrap();\r\n    let (width, height) = img.dimensions();\r\n    for y in 0..height {\r\n        for x in 0..width {\r\n            if y % (scale * 2) == 0 && x % scale == 0 {\r\n                let pix = img.get_pixel(x, y);\r\n                let mut intent = pix[0] / 3 + pix[1] / 3 + pix[2] / 3;\r\n                if pix[3] == 0 {\r\n                    intent = 0;\r\n                }\r\n                print!(\"{}\", get_ascii(intent));\r\n            }\r\n        }\r\n        if y % (scale * 2) == 0 {\r\n            println!(\"\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis function handles loading and processing the image:\r\n\r\n-   It takes the image path (`dir`) and a scaling factor (`scale`) as arguments.\r\n-   It opens the image using `image::open` and gets its dimensions (`width` and `height`).\r\n-   It iterates through each pixel (represented by `x` and `y` coordinates). However, it only processes pixels at specific intervals determined by the `scale` value. This helps reduce the number of pixels analyzed and creates a blockier but faster ASCII representation.\r\n-   For each selected pixel, it retrieves its RGB values using `img.get_pixel(x, y)`.\r\n-   It calculates the average brightness (`intent`) by dividing the sum of RGB values by 3.\r\n-   If the alpha channel value (`pix[3]`) is 0 (indicating a transparent pixel), it sets the `intent` to 0 (completely black).\r\n-   The function calls `get_ascii` with the calculated `intent` to get the corresponding ASCII character.\r\n\r\n**4. `main` Function:**\r\n\r\n```rust\r\nfn main() {\r\n    get_image(\"rick.png\", 2);\r\n}\r\n```\r\n\r\nThe `main` function is the entry point of our program. Here, it calls the `get_image` function with the path to your image (\"rick.png\") and a scaling factor of 2. You can adjust the scaling factor to control the detail level of the resulting ASCII art.\r\n\r\n**Running the Program:**\r\n\r\n1. Save the code in a Rust file (e.g., `ascii_art.rs`).\r\n2. Open your terminal, navigate to the directory containing your Rust file, and run `cargo run`.\r\n\r\nThis will execute the program, analyze the image, and print the corresponding ASCII art representation in your terminal.\r\n\r\nHere's mine:\r\n\r\n![Rick Sanchez](./rick.png)\r\n\r\nand the [Source Code](https://github.com/x0bd/rascii).\r\n\r\n**And There You Have It!**\r\n\r\nWith this code, you've built a simple yet effective ASCII art generator in Rust. Experiment with different images and scaling factors to see how they affect the output.\r\n\r\n**Thank You and Keep Creating!**\r\n";
						const data = {title:"Build a Terminal Ascii Art Generator with Rust",description:"I built a blazingly fast terminal ascii art generator.",date:new Date(1707516000000)};
						const _internal = {
							type: 'content',
							filePath: "C:/Users/synth/Dojo/oss/xoboid/src/content/blog/terminal-art/index.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
